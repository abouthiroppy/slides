(self.webpackChunkslides=self.webpackChunkslides||[]).push([[179],{1912:(e,t,n)=>{"use strict";n.r(t),n.d(t,{slides:()=>a,fusumaProps:()=>s,default:()=>i});var r=n(7401),l=n(9332);function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}function u(e,t){if(null==e)return{};var n,r,l=function(e,t){if(null==e)return{};var n,r,l={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var a=[function(e){return(0,l.kt)(r.Fragment,null,(0,l.kt)("h1",null,"Module Graph の世界"))}],s=[{classes:"title"}],p={};function i(e){var t=e.components,n=u(e,["components"]);return(0,l.kt)("wrapper",o({},p,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",null,"Module Graph の世界"))}i.isMDXComponent=!0},5580:(e,t,n)=>{"use strict";n.r(t),n.d(t,{slides:()=>a,fusumaProps:()=>s,default:()=>i});var r=n(7401),l=n(9332);function o(e,t){if(null==e)return{};var n,r,l=function(e,t){if(null==e)return{};var n,r,l={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}function u(){return(u=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}var a=[function(e){return(0,l.kt)(r.Fragment,null,(0,l.kt)("h2",null,"どのように依存グラフを作るのか?"))},function(e){return(0,l.kt)(r.Fragment,null,(0,l.kt)("div",{className:"grid"},(0,l.kt)("div",{className:"column"},(0,l.kt)("p",null,(0,l.kt)("img",{src:n(3088)}))),(0,l.kt)("div",{className:"column"},(0,l.kt)("h3",null,"有向非巡回グラフ (DAG)"),(0,l.kt)("br",null),(0,l.kt)("p",null,"エントリーポイントからのすべてのモジュールの依存を知るには、閉路がない有向グラフ(つまり一方通行で自身に戻らない)である DAG を利用する。"),(0,l.kt)("br",null),(0,l.kt)("p",null,"そして",(0,l.kt)("a",u({parentName:"p"},{href:"https://ja.wikipedia.org/wiki/%E9%A0%86%E5%BA%8F%E9%9B%86%E5%90%88"}),"半順序"),"関係とみなす\nDAG で必ず成り立つ",(0,l.kt)("a",u({parentName:"p"},{href:"https://ja.wikipedia.org/wiki/%E3%83%88%E3%83%9D%E3%83%AD%E3%82%B8%E3%82%AB%E3%83%AB%E3%82%BD%E3%83%BC%E3%83%88"}),"トポロジカルソート"),"を使い、\n依存関係を構成する。"))))},function(e){return(0,l.kt)(r.Fragment,null,(0,l.kt)("div",{className:"grid"},(0,l.kt)("div",{className:"column"},(0,l.kt)("p",null,(0,l.kt)("img",{src:n(695)}))),(0,l.kt)("div",{className:"column"},(0,l.kt)("h3",null,"トポロジカルソート"),(0,l.kt)("br",null),(0,l.kt)("p",null,"𝑂(|𝑉|+|𝐸|)"),(0,l.kt)("br",null),(0,l.kt)("p",null,"すべてのノード v1, v2 に対して、到達可能経路がある場合に必ず v1 を v2 の前に持ってくるアルゴリズムであり、\nその 2 点間の到達可能性の半順序を全順序へ拡張します。"),(0,l.kt)("br",null),(0,l.kt)("p",null,"主な実現方法として、深さ優先探索(DFS)と幅優先探索(BFS)のどちらかがあり、webpack では DFS を採用している。"),(0,l.kt)("br",null),(0,l.kt)("p",null,(0,l.kt)("a",u({parentName:"p"},{href:"https://github.com/webpack/webpack/blob/06ae0b381ddb08fac9745667a2d8f3c399473834/lib/MultiCompiler.js#L194"}),"webpack での実装例")))))},function(e){return(0,l.kt)(r.Fragment,null,(0,l.kt)("pre",null,(0,l.kt)("code",u({parentName:"pre"},{className:"language-javascript"}),"const vertices = new Map();\nconst visited = new Set();\nconst res = [];\n\nvertices.set('v', ['a']); //      v -> a\nvertices.set('a', ['b', 'c']); // a -> b, a -> c\nvertices.set('b', ['d']); //      b -> d\nvertices.set('c', ['b', 'd']); // c -> d, c -> d\nvertices.set('d', []); //         d\n\nfunction dfs(name, stack = new Set()) {\n  if (visited.has(name)) return;\n\n  visited.add(name);\n  stack.add(name);\n\n  const edges = vertices.get(name);\n\n  for (const edge of edges) {\n    // 再帰スタックに頂点が入っている場合、閉路グラフである\n    if (stack.has(edge)) {\n      console.log('Cyclic Graph found.');\n      return;\n    }\n    dfs(edge, stack);\n  }\n  stack.delete(name);\n  res.push(name);\n}\n\nfor (const [name] of vertices) {\n  dfs(name);\n}\n\nconsole.log('res', res.reverse()); // res [ 'v', 'a', 'c', 'b', 'd' ]\n")))}],s=[{sectionTitle:"どのように依存グラフを作るのか?"},{},{},{}],p={};function i(e){var t=e.components,r=o(e,["components"]);return(0,l.kt)("wrapper",u({},p,r,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h2",null,"どのように依存グラフを作るのか?"),(0,l.kt)("hr",null),(0,l.kt)("p",null,(0,l.kt)("img",{src:n(3088)})),(0,l.kt)("h3",null,"有向非巡回グラフ (DAG)"),(0,l.kt)("br",null),(0,l.kt)("p",null,"エントリーポイントからのすべてのモジュールの依存を知るには、閉路がない有向グラフ(つまり一方通行で自身に戻らない)である DAG を利用する。"),(0,l.kt)("br",null),(0,l.kt)("p",null,"そして",(0,l.kt)("a",u({parentName:"p"},{href:"https://ja.wikipedia.org/wiki/%E9%A0%86%E5%BA%8F%E9%9B%86%E5%90%88"}),"半順序"),"関係とみなす\nDAG で必ず成り立つ",(0,l.kt)("a",u({parentName:"p"},{href:"https://ja.wikipedia.org/wiki/%E3%83%88%E3%83%9D%E3%83%AD%E3%82%B8%E3%82%AB%E3%83%AB%E3%82%BD%E3%83%BC%E3%83%88"}),"トポロジカルソート"),"を使い、\n依存関係を構成する。"),(0,l.kt)("hr",null),(0,l.kt)("p",null,(0,l.kt)("img",{src:n(695)})),(0,l.kt)("h3",null,"トポロジカルソート"),(0,l.kt)("br",null),(0,l.kt)("p",null,"𝑂(|𝑉|+|𝐸|)"),(0,l.kt)("br",null),(0,l.kt)("p",null,"すべてのノード v1, v2 に対して、到達可能経路がある場合に必ず v1 を v2 の前に持ってくるアルゴリズムであり、\nその 2 点間の到達可能性の半順序を全順序へ拡張します。"),(0,l.kt)("br",null),(0,l.kt)("p",null,"主な実現方法として、深さ優先探索(DFS)と幅優先探索(BFS)のどちらかがあり、webpack では DFS を採用している。"),(0,l.kt)("br",null),(0,l.kt)("p",null,(0,l.kt)("a",u({parentName:"p"},{href:"https://github.com/webpack/webpack/blob/06ae0b381ddb08fac9745667a2d8f3c399473834/lib/MultiCompiler.js#L194"}),"webpack での実装例")),(0,l.kt)("hr",null),(0,l.kt)("pre",null,(0,l.kt)("code",u({parentName:"pre"},{className:"language-javascript"}),"const vertices = new Map();\nconst visited = new Set();\nconst res = [];\n\nvertices.set('v', ['a']); //      v -> a\nvertices.set('a', ['b', 'c']); // a -> b, a -> c\nvertices.set('b', ['d']); //      b -> d\nvertices.set('c', ['b', 'd']); // c -> d, c -> d\nvertices.set('d', []); //         d\n\nfunction dfs(name, stack = new Set()) {\n  if (visited.has(name)) return;\n\n  visited.add(name);\n  stack.add(name);\n\n  const edges = vertices.get(name);\n\n  for (const edge of edges) {\n    // 再帰スタックに頂点が入っている場合、閉路グラフである\n    if (stack.has(edge)) {\n      console.log('Cyclic Graph found.');\n      return;\n    }\n    dfs(edge, stack);\n  }\n  stack.delete(name);\n  res.push(name);\n}\n\nfor (const [name] of vertices) {\n  dfs(name);\n}\n\nconsole.log('res', res.reverse()); // res [ 'v', 'a', 'c', 'b', 'd' ]\n")))}i.isMDXComponent=!0},7887:(e,t,n)=>{"use strict";n.r(t),n.d(t,{slides:()=>a,fusumaProps:()=>s,default:()=>i});var r=n(7401),l=n(9332);function o(e,t){if(null==e)return{};var n,r,l=function(e,t){if(null==e)return{};var n,r,l={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}function u(){return(u=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}var a=[function(e){return(0,l.kt)(r.Fragment,null,(0,l.kt)("h2",null,"ランタイムではどのように処理されるのか？"))},function(e){return(0,l.kt)(r.Fragment,null,(0,l.kt)("p",null,"ランタイムでは、エントリーポイントから再帰的に走査しモジュールを実行していく。",(0,l.kt)("br",{parentName:"p"}),"\n","サンドボックス化が必要なため、IIFE を使って引数にすべてのモジュールを渡しエントリーポイントから関係のあるコードを実行する。"),(0,l.kt)("p",null,"詳しくは、",(0,l.kt)("a",u({parentName:"p"},{href:"https://blog.hiroppy.me/entry/create-module-bundler-preparation"}),"module bundler の作り方(準備編)"),"を参照。"))},function(e){return(0,l.kt)(r.Fragment,null,(0,l.kt)("pre",null,(0,l.kt)("code",u({parentName:"pre"},{className:"language-javascript"}),"// 例なのでESM等の対応はないが仕組みは一緒\n// IIFEの引数に全てのモジュールが入ったobjectを渡す\n((modules) => {\n  const usedModules = {}; // キャッシュ\n\n  function require(moduleId) {\n    if (usedModules[moduleId]) {\n      return usedModules[moduleId].exports;\n    }\n\n    // ModuleId(0, 1, ...)を入れ、最低限必要なexportsを定義し初期化\n    const module = (usedModules[moduleId] = { exports: {} });\n\n    // 自身の関数であるrequireを渡すことにより、それぞれのモジュール内でこの関数を実行し再帰走査する\n    // つまり、それぞれのモジュール内のmodule/requireはここで上書きされる\n    modules[moduleId](module, module.exports, require);\n\n    return module.exports;\n  }\n\n  return require(0); // entry pointである0(index.js)から開始\n})({\n  0 /*index.js*/: function (module, exports, require) {\n    const m = require(1);\n    m('hello world');\n  },\n  1 /* foo.js */: function (module, exports, require) {\n    module.exports = function m(txt) {\n      console.log('module', txt);\n    };\n  },\n});\n")))}],s=[{sectionTitle:"ランタイムではどのように処理されるのか？"},{},{}],p={};function i(e){var t=e.components,n=o(e,["components"]);return(0,l.kt)("wrapper",u({},p,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h2",null,"ランタイムではどのように処理されるのか？"),(0,l.kt)("hr",null),(0,l.kt)("p",null,"ランタイムでは、エントリーポイントから再帰的に走査しモジュールを実行していく。",(0,l.kt)("br",{parentName:"p"}),"\n","サンドボックス化が必要なため、IIFE を使って引数にすべてのモジュールを渡しエントリーポイントから関係のあるコードを実行する。"),(0,l.kt)("p",null,"詳しくは、",(0,l.kt)("a",u({parentName:"p"},{href:"https://blog.hiroppy.me/entry/create-module-bundler-preparation"}),"module bundler の作り方(準備編)"),"を参照。"),(0,l.kt)("hr",null),(0,l.kt)("pre",null,(0,l.kt)("code",u({parentName:"pre"},{className:"language-javascript"}),"// 例なのでESM等の対応はないが仕組みは一緒\n// IIFEの引数に全てのモジュールが入ったobjectを渡す\n((modules) => {\n  const usedModules = {}; // キャッシュ\n\n  function require(moduleId) {\n    if (usedModules[moduleId]) {\n      return usedModules[moduleId].exports;\n    }\n\n    // ModuleId(0, 1, ...)を入れ、最低限必要なexportsを定義し初期化\n    const module = (usedModules[moduleId] = { exports: {} });\n\n    // 自身の関数であるrequireを渡すことにより、それぞれのモジュール内でこの関数を実行し再帰走査する\n    // つまり、それぞれのモジュール内のmodule/requireはここで上書きされる\n    modules[moduleId](module, module.exports, require);\n\n    return module.exports;\n  }\n\n  return require(0); // entry pointである0(index.js)から開始\n})({\n  0 /*index.js*/: function (module, exports, require) {\n    const m = require(1);\n    m('hello world');\n  },\n  1 /* foo.js */: function (module, exports, require) {\n    module.exports = function m(txt) {\n      console.log('module', txt);\n    };\n  },\n});\n")))}i.isMDXComponent=!0},7802:(e,t,n)=>{"use strict";n.r(t),n.d(t,{slides:()=>a,fusumaProps:()=>s,default:()=>i});var r=n(7401),l=n(9332);function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}function u(e,t){if(null==e)return{};var n,r,l=function(e,t){if(null==e)return{};var n,r,l={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var a=[function(e){return(0,l.kt)(r.Fragment,null,(0,l.kt)("h2",null,"まとめ"),(0,l.kt)("br",null),(0,l.kt)("br",null),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"モジュールの依存関係はグラフ理論を使い表現できる"),(0,l.kt)("li",{parentName:"ul"},"ランタイムでは、走査での再帰処理が走るので深さはパフォーマンスに影響がでる可能性がある",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"そのための Scope Hoisting などのアルゴリズムがある")))))}],s=[{sectionTitle:"まとめ"}],p={};function i(e){var t=e.components,n=u(e,["components"]);return(0,l.kt)("wrapper",o({},p,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h2",null,"まとめ"),(0,l.kt)("br",null),(0,l.kt)("br",null),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"モジュールの依存関係はグラフ理論を使い表現できる"),(0,l.kt)("li",{parentName:"ul"},"ランタイムでは、走査での再帰処理が走るので深さはパフォーマンスに影響がでる可能性がある",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"そのための Scope Hoisting などのアルゴリズムがある")))))}i.isMDXComponent=!0},6551:(e,t,n)=>{"use strict";n.r(t),n.d(t,{slides:()=>a,fusumaProps:()=>s,default:()=>i});var r=n(7401),l=n(9332);function o(e,t){if(null==e)return{};var n,r,l=function(e,t){if(null==e)return{};var n,r,l={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}function u(){return(u=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}var a=[function(e){return(0,l.kt)(r.Fragment,null,(0,l.kt)("h2",null,"参考資料"),(0,l.kt)("br",null),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",u({parentName:"li"},{href:"http://lpha-z.hatenablog.com/entry/2019/02/03/231500"}),"DAG のトポロジカルソートのうち最適なものを見つけたい")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",u({parentName:"li"},{href:"https://github.com/hiroppy/the-sample-of-module-bundler"}),"hiroppy/the-sample-of-module-bundler")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",u({parentName:"li"},{href:"https://blog.hiroppy.me/entry/create-module-bundler-preparation"}),"module bundler の作り方(準備編)"))))}],s=[{}],p={};function i(e){var t=e.components,n=o(e,["components"]);return(0,l.kt)("wrapper",u({},p,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h2",null,"参考資料"),(0,l.kt)("br",null),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",u({parentName:"li"},{href:"http://lpha-z.hatenablog.com/entry/2019/02/03/231500"}),"DAG のトポロジカルソートのうち最適なものを見つけたい")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",u({parentName:"li"},{href:"https://github.com/hiroppy/the-sample-of-module-bundler"}),"hiroppy/the-sample-of-module-bundler")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",u({parentName:"li"},{href:"https://blog.hiroppy.me/entry/create-module-bundler-preparation"}),"module bundler の作り方(準備編)"))))}i.isMDXComponent=!0},9720:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>m,fusumaProps:()=>c,slides:()=>i});var r=n(7401),l=n(6465),o=function(e){var t=e.type,n=e.url,l=e.children;return r.createElement("a",{key:t,href:n,"aria-label":"".concat(t," ").concat(n)},l)},u=function(){return r.createElement("div",{className:"sns-list sns-list-end"},r.createElement(o,{type:"site",url:"https://hiroppy.me"},r.createElement(l.xng,null)),r.createElement(o,{type:"twitter",url:"https://twitter.com/about_hiroppy"},r.createElement(l.fWC,null)),r.createElement(o,{type:"github",url:"https://github.com/hiroppy"},r.createElement(l.hJX,null)),r.createElement(o,{type:"facebook",url:"https://www.facebook.com/abouthiroppy"},r.createElement(l.Am9,null)),r.createElement(o,{type:"linkedin",url:"https://www.linkedin.com/in/hiroppy"},r.createElement(l.ltd,null)))},a=n(9332);function s(){return(s=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}function p(e,t){if(null==e)return{};var n,r,l=function(e,t){if(null==e)return{};var n,r,l={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var i=[function(e){return(0,a.kt)(r.Fragment,null,(0,a.kt)("h1",null,"The End"),(0,a.kt)("br",null),(0,a.kt)(u,(l="SNSList",(n="mdxType")in(t={mdxType:"SNSList"})?Object.defineProperty(t,n,{value:l,enumerable:!0,configurable:!0,writable:!0}):t[n]=l,t)));var t,n,l}],c=[{}],d={};function m(e){var t=e.components,n=p(e,["components"]);return(0,a.kt)("wrapper",s({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",null,"The End"),(0,a.kt)("br",null),(0,a.kt)(u,{mdxType:"SNSList"}))}m.isMDXComponent=!0},9105:(e,t,n)=>{"use strict";n.d(t,{Z:()=>o});var r=n(8814),l=n.n(r)()((function(e){return e[1]}));l.push([e.id,"// extracted by mini-css-extract-plugin\nexport {};",""]);const o=l},7899:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>a});var r=n(3379),l=n.n(r),o=n(9105),u={insert:"head",singleton:!1};l()(o.Z,u);const a=o.Z.locals||{}},3088:(e,t,n)=>{"use strict";e.exports=n.p+"f1183961d439a4cc0ca1.webp"},695:(e,t,n)=>{"use strict";e.exports=n.p+"553d5665a813d39a4894.webp"},6235:(e,t,n)=>{var r={"./0-title.md":1912,"./01-dependency-graph.mdx":5580,"./02-webpack-output.md":7887,"./03-summary.md":7802,"./04-ref.md":6551,"./z-end.mdx":9720};function l(e){var t=o(e);return n(t)}function o(e){if(!n.o(r,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return r[e]}l.keys=function(){return Object.keys(r)},l.resolve=o,e.exports=l,l.id=6235}},function(e){"use strict";var t;t=e.x,e.x=()=>{var n=t();return e.E(487),n}},[[7751,666,736],[6107,666,736],[9969,666,736]]]);